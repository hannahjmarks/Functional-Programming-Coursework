--Functional Programming Coursework slide.hs
--Hannah Marks
--B810836



import System.Random
import Data.List


----Part 1----


type Point = (Float,Float)



--takes the y values of the start point and a supporting point i and calculates the
--velocity at point i. 

velocity :: Float -> Float -> Float
velocity y0 y1 = sqrt (2*9.81*(y0-y1))



--takes 2 adjacent points uses pythagorean theorum to calculate the distance between them.

distance :: Point -> Point -> Float
distance (x0,y0) (xi,yi) = sqrt (((xi-x0)^2)+((y0-yi)^2))



--takes the distance between 2 adjacent points and divides it by the average velocity
--average velocity is calculated by dividing the sum of the initial and final velocity by 2.

time :: Float -> Float -> Float -> Float
time d v0 v1 = (2*d)/(v0+v1)



--reccursive function for use in arrange_in_pairs function
--takes a list of points and an integer and makes a new list of the points arranged in pairs.

make_pair :: [Point] -> Int -> [(Point,Point)]
make_pair as 0 = []
make_pair as n = (make_pair as (n-1))++[(as!!(n-1),as!!n)]



--takes the start and end points of the slide as well as a list of supporting points and
--returns a list of pairs of points for use in later functions.

arrange_in_pairs :: Point -> Point -> [Point] -> [(Point,Point)]
arrange_in_pairs (x0,y0) (xn,yn) ps = as++xs++bs
 where
  n = (length ps - 1)
  as = [((x0,y0),ps!!0)]
  xs = make_pair ps n
  bs = [(ps!!n,(xn,yn))]



--takes a list of pairs of points and calculates the slide time between the 2 points in the
--pair, it then appends the time to a list which is returned for use in the total_time function.

times :: [(Point,Point)] -> Int -> [Float]
times as 0 = [time (distance (fst(as!!0)) (snd(as!!0))) 
                     (velocity (snd(fst(as!!0))) (snd(snd(as!!0))))
                     (velocity (snd(fst(as!!0))) (snd(fst(as!!0))))]
times as n = [time (distance (fst(as!!n)) (snd(as!!n))) 
                     (velocity (snd(fst(as!!0))) (snd(snd(as!!n))))
                     (velocity (snd(fst(as!!0))) (snd(fst(as!!n))))]++(times as (n-1))



--takes a start point, end point and a list of supporting points and calculates the total
--slide time of an individual slide by calling the arrange in pairs function on the input
--and using the resulting list as an input for the times function. The list generated by
--the times function is then summed to give total slide time.

total_time :: Point -> Point -> [Point] -> Float
total_time (x0,y0) (xn,yn) ps = sum bs
 where
  as = arrange_in_pairs (x0,y0) (xn,yn) ps
  n = ((length as)-1)
  bs = times as n





----Part 2----


type Candidate = (Point,Point,[Point],Float)



--uses list comprehension to make a list of candidates from common start and end points as
--well as a list of lists of supporting points. 'i' is used to index the list of lists in 
--order to generate a list of unique candidates and is increased by 1 for each itteration.

make_candidates :: Point -> Point -> [[Point]] -> [Candidate]
make_candidates (x0,y0) (xn,yn) pss = [((x0,y0),(xn,yn),pss!!i,(slide_time i))| i <- [0..n]]
 where
  n = (length pss)-1
  slide_time i = total_time (x0,y0) (xn,yn) (pss!!i)



--takes a list of candidates and sorts them by comparing the total_time for each, returning
--a sorted list of candidates.

sort_by_time :: [Candidate] -> [Candidate]
sort_by_time cs = sortBy (\(_,_,_,a) (_,_,_,b) -> compare a b) cs



--converts Point type variables into a string with the desired formatting.

point_to_string :: Point -> String
point_to_string (x,y) = show x ++ " " ++ show y ++ "\n"



--takes a candidate and calls the point_to_string function on the start and end points, it
--then uses the reccursive function 'b' to call point_to_string on all of the supporting
--points and finally shows the total time for the candidate.

candidate_to_string :: Candidate -> String
candidate_to_string ((x0,y0),(xn,yn),ps,t) = (point_to_string (x0,y0)) ++ (b n') 
                                              ++ (point_to_string (xn,yn)) 
                                              ++ "Time: " ++ show t
 where
  n' = (length ps)-1
  b 0 = point_to_string (ps!!0)
  b n = (b (n-1)) ++ (point_to_string (ps!!n))



--takes 2 lists of floats and creates a list of lists of points using list comprehension. 
--The numbers in the first list are used as x values and the second list contains y 
--values. The sub-function assigned to ps drops a multiple of n elements from bs and
--then takes the first n elements of the new list.

divide_list :: [Float] -> [Float] -> [[Point]]
divide_list as bs = [zip as (ps!!j)| j <- [0..p]]
 where
  n = length as
  m = length bs
  x = div m n
  ps = [take n (drop (i*n) bs)|i <- [0..(x-1)]]
  p = (length ps)-1





----Part 3----


--takes an integer for the number of iterations, a pair of float numbers used to specify 
--the output range of the generator and a random number generator. Returns a list of floats
--and a new generator

random_list :: Int -> (Float, Float) -> StdGen -> ([Float], StdGen)
random_list 0 _ gen = ([], gen)
random_list n minmax gen = ((r:rs), g2)
 where
  (r, g) = randomR minmax gen
  (rs, g2) = random_list (n-1) minmax g



--takes the number of candidates, common start and end points, a list of x values, a minimum
--and maximum y value and a random number generator and produces a list of candidates.

create_random_candidates :: Int -> Point -> Point -> [Float] -> (Float,Float) -> StdGen -> ([Candidate], StdGen)
create_random_candidates n (x0,y0) (xn,yn) xs minmax gen = (ds, gen)
 where
  x = length xs
  (as, b) = random_list (x*n) minmax gen
  cs = divide_list xs as
  ds = make_candidates (x0,y0) (xn,yn) cs
--using x*n so that the list generated will produce a list of points for the number of candidates
--when run in the divide list function.

  



----Part 4----


-- takes a list of candidates (cs) an integer (n) and a generator (g) and calls the pairs
-- function on a list of pairs of candidates generated using list comprehension.

crossover :: [Candidate] -> Int -> StdGen -> ([Candidate], StdGen)
crossover cs n g = (cs ++ cs_new, g1)
 where
  pairs = [(( cs !! c1), (cs !! c2)) | c1 <- [0..(n-1)], c2 <- [(c1+1)..(n-1)]]
  (cs_new, g1) = cross_pairs pairs g



-- takes a list of pairs of candidates and calls the cross_pair function for each pair in
-- the list and returns a new list of crossbred candidates.

cross_pairs :: [( Candidate, Candidate)] -> StdGen -> ([Candidate], StdGen)
cross_pairs [] g = ([], g)
cross_pairs (cp:cps) g = (c:cs, g2)
 where
  (c, g1) = cross_pair cp g
  (cs, g2) = cross_pairs cps g1



-- takes 2 candidates and calls the cross_supp function to generate a new candidate with
-- supporting points taken from either input candidate

cross_pair :: (Candidate, Candidate) -> StdGen -> (Candidate, StdGen)
cross_pair (( s, e, ps1, _ ), (_, _, ps2, _)) g = (( s, e, ps, t ), g1)
 where
  (ps, g1) = cross_supp ps1 ps2 g
  t = total_time s e ps



-- takes 2 lists of points and uses a random number generator to give a float (r) between 0
-- and 1. If r is less than 0.5 then the supporting point from the 1st list is used if not
-- the point from the 2nd list is used. The function cycles through all of the list elements
-- and returns a new list of supporting points.

cross_supp :: [Point] -> [Point] -> StdGen -> ([Point], StdGen)
cross_supp [] [] g = ([], g)
cross_supp (c1:cs1) (c2:cs2) g = (( if r < 0.5 then c1 else c2) : xs, g2)
 where
  ( r , g1) = randomR (0 :: Float, 1 :: Float) g
  (xs, g2) = cross_supp cs1 cs2 g1





